# .github/workflows/production-deployment.yml
name: Production Deployment

on:
  push:
    tags: # Trigger on new tags that match the pattern
      - "v[0-9]+.[0-9]+.[0-9]+-build.[0-9]+" # e.g. v1.0.1-build.123

concurrency:
  group: "production-deployment-${{ github.ref }}"
  cancel-in-progress: true

permissions:
  id-token: write
  contents: write # For GitHub Release creation

jobs:
  build_and_deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code for the specific tag
        uses: actions/checkout@v4
        with:
          ref: ${{ github.ref }} # Checks out the specific tag that triggered the workflow
          fetch-depth: 0 # For release notes

      - name: Extract Version and Build Info from Tag
        id: version_info
        run: |
          TAG_NAME="${{ github.ref_name }}" # e.g., v1.0.1-build.123
          # Extract package version (e.g., 1.0.1)
          APP_VERSION=$(echo "$TAG_NAME" | sed -n 's/^v\([0-9]*\.[0-9]*\.[0-9]*\)-build\.[0-9]*$/\1/p')
          # Extract build number (e.g., 123)
          BUILD_NUMBER=$(echo "$TAG_NAME" | sed -n 's/^v[0-9]*\.[0-9]*\.[0-9]*-build\.\([0-9]*\)$/\1/p')

          if [ -z "$APP_VERSION" ] || [ -z "$BUILD_NUMBER" ]; then
            echo "Error: Could not parse APP_VERSION or BUILD_NUMBER from tag $TAG_NAME"
            # Fallback to package.json version if parsing fails, though tag should be the source of truth here
            APP_VERSION=$(node -p "require('./package.json').version")
            echo "Fallback APP_VERSION: $APP_VERSION"
            # Build number might be harder to get as a fallback without reading versions.json for the specific context
          fi

          echo "Release Tag: $TAG_NAME"
          echo "App Version: $APP_VERSION"
          echo "Build Number: $BUILD_NUMBER"
          echo "release_tag=$TAG_NAME" >> $GITHUB_OUTPUT
          echo "app_version=$APP_VERSION" >> $GITHUB_OUTPUT
          echo "build_number=$BUILD_NUMBER" >> $GITHUB_OUTPUT

      # ... (Setup Node, Install Deps, Build Plugin - same as before) ...
      - name: Setup node
        uses: actions/setup-node@v4
        with:
          node-version-file: .nvmrc
          cache: "yarn"
          cache-dependency-path: yarn.lock
        env:
          SKIP_YARN_COREPACK_CHECK: "1"
      - run: corepack enable

      - name: Install dependencies
        run: yarn install --immutable

      - name: Build iOS notification extension plugin
        run: |
          yarn plugins:build:notification-service-extension

      - name: Setup EAS
        uses: expo/expo-github-action@v8
        with:
          eas-version: latest
          token: ${{ secrets.EXPO_TOKEN }}
          packager: yarn
          eas-cache: true
          patch-watchers: true

      - name: Build and Submit iOS production
        id: eas_build
        env:
          RELEASE_TAG_VAL: ${{ steps.version_info.outputs.release_tag }}
        run: |
          CLI_MESSAGE="Production build for ${RELEASE_TAG_VAL}"
          echo "EAS Build Message: $CLI_MESSAGE"
          # EAS should pick up version from package.json and build number from app.config.ts
          # which were set correctly by prepare-release.yml for this tag
          eas build --platform ios --profile production --non-interactive --auto-submit --message "$CLI_MESSAGE"
          echo "EAS Build and Submission successful."

      - name: Create GitHub Release
        if: success()
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          RELEASE_TAG: ${{ steps.version_info.outputs.release_tag }}
          APP_VERSION: ${{ steps.version_info.outputs.app_version }} # Just the semver part
          BUILD_NUM: ${{ steps.version_info.outputs.build_number }}
        run: |
          echo "Creating GitHub Release for $RELEASE_TAG..."
          gh release create "$RELEASE_TAG" \
            --title "Release $APP_VERSION (Build $BUILD_NUM)" \
            --generate-notes \
            --target ${{ github.ref_name }} # Target the tag itself
          echo "GitHub Release $RELEASE_TAG created successfully."
